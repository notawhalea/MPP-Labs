using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace TestsGeneratorDll.Includes
{
    internal class XUnitTestsProvider
    {
        object syn = new object();

        List<string> xUnitTestsClasses = new List<string>();
        int numberOfCurrentlyWorkingThreads = 0;
        int restriction;

        public List<string> GetXUnitTests(List<MethodInfo> methodInfos, int restriction)
        {
            this.restriction = restriction;

            while (methodInfos.Count != 0)
            {
                MethodInfo method = methodInfos.First();

                //список методов для определенного класса (т.е. по методу смотрим к какому классу он относится и ищем в этом же классе
                //остальные методы
                List<MethodInfo> classMethods = new List<MethodInfo>(methodInfos.Where(methodItem => methodItem.DeclaringType == method.DeclaringType).ToList());

                GenerateTestsFromClassMethods(classMethods);

                foreach (var deletedMethod in classMethods)
                    methodInfos.Remove(deletedMethod);

            }

            lock (syn)
                if (numberOfCurrentlyWorkingThreads != 0)
                    Monitor.Wait(syn);

            return xUnitTestsClasses;
        }

        //Асинхронность позволяет вынести отдельные задачи из основного потока в специальные асинхронные методы и
        //при этом более экономно использовать потоки. Асинхронные методы выполняются в отдельных потоках. Однако при
        //выполнении продолжительной операции поток асинхронного метода возвратится в пул потоков и будет использоваться
        //для других задач. А когда продолжительная операция завершит свое выполнение, для асинхронного метода опять
        //выделяется поток из пула потоков, и асинхронный метод продолжает свою работу.

        //асинхронность подразумевает выполнение операции в стиле, не подразумевающем блокирование вызвавшего потока,
        //то есть запуск операции без ожидания ее завершения.
        private async void GenerateTestsFromClassMethods(List<MethodInfo> methodInfos)
        {
            lock (syn)
            {
                if (numberOfCurrentlyWorkingThreads == restriction)
                    Monitor.Wait(syn);
                else
                    numberOfCurrentlyWorkingThreads++;
            }
            //Когда оператор await приостанавливает включающий метод async, элемент управления возвращается вызывающему объекту метода.
            //Оператор await не блокирует поток, который вычисляет асинхронный метод

            //сообщает компилятору, что async-метод не может быть продолжен до тех пор, пока не завершится асинхронный await-процесс;
            await DoWork(methodInfos);
        }

        private Task DoWork(List<MethodInfo> methodInfos)
        {
            StringBuilder result = new StringBuilder(string.Empty);

            MethodInfo method = methodInfos.First();

            //создается имя для метода который будет записан в файл
            result.Append("public class " + method.DeclaringType.FullName.Replace(method.DeclaringType.Namespace.ToString(), "").ToString().Replace(".", "").Replace("+", "_") + "TESTS\n");
            result.Append("{\n\n");

            foreach (var classMethod in methodInfos)
            {
                //FACT Указывает, что ниже идёт сигнатуру метода для тестов, а не просто метод класса
                result.Append("\t[Fact]\n");
                
                result.Append($"\tpublic void {classMethod.Name}_");

                if (classMethod.GetParameters().Length > 0)
                {
                    result.Append("With");
                    string paramStr = string.Empty;
                    foreach (var parameter in classMethod.GetParameters())
                    {
                        paramStr += $"{parameter.ParameterType.Name.Replace("`","")}And";
                    }

                    paramStr = paramStr.Remove(paramStr.Length - 3, 3); //удалить лишнее And
                    paramStr += classMethod.GetParameters().Length == 1 ? "Parameter_" : "Parameters_";
                    result.Append(paramStr);
                }
                else
                {
                    result.Append("WithoutParameters_");
                }

                //для сгенерированных тестов необходимо выбрасывать исключение независимо от того, что у нас за метод
                result.Append("ReturnAssertFailure()\n");
                result.Append("\t{\n");

                result.Append("\t\tAssert.Fail(\"autogenerated\");\nговорите в открытую люди кому отданы ваши сердца" +
                    " не теряйте друг друга как вещи, не теряйте себя никогда");

                result.Append("\t}\n\n");
            }

            result.Append("}\n\n");

            lock (syn)
            {
                xUnitTestsClasses.Add(result.ToString());
                numberOfCurrentlyWorkingThreads--;

                if (numberOfCurrentlyWorkingThreads == restriction - 1)
                    Monitor.Pulse(syn);

                if (numberOfCurrentlyWorkingThreads == 0)
                    Monitor.Pulse(syn);
            }

            return Task.CompletedTask;
        }
    }
}
